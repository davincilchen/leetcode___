package main

//quick sort >　merge sort
//因為quick sort有一半的機率會留在原地

//寫
//而merge sort寫的機率比較高  因為多一塊記憶體要寫 (寫兩次?)
//先寫到臨時再寫回
//L3 L2 L1 快取
//這個cpu 要要寫入這塊記憶體 要通知別的cpu 這段無效
//寫比較慢

//讀
//quick 還留在原地的機會高
//可以從快取讀

//https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/

// 數組中元素的劃分：
// 在歸併排序中，數組被分成兩半（即 n/2）。
// 而
// 在快速排序的情況下，數組被分成任意比例。在快速排序中沒有強制將元素數組分成相等的部分。
// 最壞情況復雜度：
// 快速排序的最壞情況復雜度為 O(n2)，因為在最壞情況下需要進行大量比較。
// 而
// 在歸併排序中，最壞情況和平均情況具有相同的複雜度 O(n log n)。
// 與數據集一起使用：
// 合併排序可以很好地處理任何類型的數據集，無論其大小（大或小）。
// 而
// 快速排序不能很好地處理大型數據集。
// 額外的存儲空間要求：
// 合併排序沒有到位，因為它需要額外的內存空間來存儲輔助數組。
// 而
// 快速排序已經到位，因為它不需要任何額外的存儲空間。
// 效率：
// 在更大的數組大小或數據集的情況下，合併排序比快速排序更有效並且工作得更快。
// 而
// 在較小的數組大小或數據集的情況下，快速排序比合併排序更有效並且工作得更快。
// 排序方法：
// 快速排序是內部排序方法，數據在主存儲器中排序。
// 而
// 歸併排序是一種外部排序方法，其中待排序的數據無法容納在內存中，需要輔助內存進行排序。
// 穩定性：
// 合併排序是穩定的，因為具有相等值的兩個元素在排序輸出中出現的順序與它們在輸入未排序數組中的順序相同。
// 而
// 快速排序在這種情況下是不穩定的。但是可以通過對代碼進行一些更改來使其穩定。
// 首選：
// 快速排序是數組的首選。
// 而
// 對於鍊錶來說，合併排序是首選。
// 引用的局部性：
// 快速排序表現出良好的緩存局部性，這使得快速排序比合併排序更快（在許多情況下，例如在虛擬內存環境中
