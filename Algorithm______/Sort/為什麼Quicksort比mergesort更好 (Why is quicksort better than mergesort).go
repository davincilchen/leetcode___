package main

// /https://zh-tw.coderbridge.com/discussions/705683bb6f924a72a7deeab8cf95910b

// 問題敘述
// 為什麼Quicksort比mergesort更好? (Why is quicksort better than mergesort?)

// 採訪中有人問我這個問題。它們都是O(nlogn),但是大多數人使用Quicksort而不是Mergesort。這是為什麼?

// 參考解法
// 方法 1:
// 正如許多人所指出的,Quicksort的平均案例性能比mergesort更快。但這只有在假設您有恆定的時間按需訪問任何內存時才是正確的。

// 在RAM中,此假設通常不太差(由於高速緩存,它並不總是正確的,但也不太糟)。但是,如果您的數據結構足夠大,可以存儲在磁盤上,那麼您的平均磁盤每秒會進行200次隨機尋道,因此quicksort會被殺死。但是,同一個磁盤沒有順序順序每秒讀取或寫入兆字節數據的麻煩。這正是mergesort所做的。

// 因此,如果必須在磁盤上對數據進行排序,那麼您真的很想在mergesort上使用一些變體。 (通常,您先對子列表進行快速排序,然後在某個大小閾值以上開始將它們合併在一起。)

// 此外,如果您必須對如此大小的數據集執行任何操作,請認真考慮如何避免尋找磁盤。例如,這就是為什麼建議在數據庫中進行大數據加載之前刪除索引,然後稍後再重建索引的標準建議。在加載期間保持索引意味著不斷尋求磁盤。相反,如果刪除索引,則數據庫可以通過以下方式重建索引:首先對要處理的信息進行排序(當然要使用mergesort!),然後將其加載到該索引的BTREE數據結構中。 (BTREE本質上是保持順序的,因此您可以從排序的數據集中裝入一個,而很少有磁盤尋道。)

// 在很多情況下,了解如何避免磁盤尋道使我使數據處理作業花費數小時而不是數天或數週。

// 方法 2:
// Quicksort具有O(n2 )最壞情況運行時和O(n logn )平均情況運行時。但是,在許多情況下合併排序會更好,因為許多因素會影響算法的運行時間,並且將它們放在一起時,quicksort會勝出。

// 特別是,經常引用的排序算法運行時是指執行比較或對數據進行排序所需的交換次數。這確實是一個很好的性能衡量標準,尤其是因為它獨立於底層硬件設計。但是,其他因素(例如引用的局部性(即,我們是否讀取了很多可能在緩存中的元素?))在當前硬件上也起著重要作用。特別是Quicksort,幾乎不需要額外的空間,並且具有良好的緩存局部性,因此在許多情況下,它比合併排序要快。

// 此外,通過適當選擇樞軸(例如隨機選擇它),幾乎完全可以避免quicksort的最壞運行時間O(n2 ),這很容易。

// 實際上,quicksort的許多現代實現(尤其是libstdc ++的std::sort )實際上是introsort,其理論上最差的情況是O(n logn ),與合併排序相同。它通過限制遞歸深度並切換到其他算法來實現此目的(一旦超過logn 。

// 方法 3:
// 實際上,QuickSort是O(n2 )。其平均情況下的運行時間為O(nlog(n)),但最壞情況下的情況為O(n2 ),當您在包含很少的唯一項目的列表上運行它時,會發生這種情況。隨機化為O(n)。當然,這不會改變最壞的情況,它只是防止惡意用戶使您的排序花費很長時間。

// QuickSort之所以受歡迎,是因為它:

// 就地(MergeSort要求額外的內存與要排序的元素數量成線性關係)。
// 有一個小的隱藏常數。
